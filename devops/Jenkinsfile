def cwbPod = """
spec:
  containers:
  - name: cwb-small
    image: nx-example-build-node:14.17.4
    imagePullPolicy: IfNotPresent
    command:
    - sleep
    args:
    - infinity
    volumeMounts:
      - name: cwb-vol
        mountPath: /app/
  - name: cwb-lint
    image: nx-example-build-node:14.17.4
    imagePullPolicy: IfNotPresent
    command:
    - sleep
    args:
    - infinity
    volumeMounts:
      - name: cwb-vol
        mountPath: /app/
    resources:
      limits:
        memory: "1500Mi"
      requests:
        memory: "1000Mi"
    livenessProbe:
      exec:
        command:
          - bin/bash
          - -c
          - ./liveness.sh
      initialDelaySeconds: 60
      timeoutSeconds: 25
  volumes:
  - name: cwb-vol
    persistentVolumeClaim:
        claimName: cwb-pvc
"""

def cwbUnitTestPod = """
spec:
  containers:
  - name: cwb-test
    image: nx-example-build-node:14.17.4
    imagePullPolicy: IfNotPresent
    command:
    - sleep
    args:
    - infinity
    volumeMounts:
      - name: cwb-vol
        mountPath: /app/
    resources:
      limits:
        memory: "2.5Gi"
      requests:
        memory: "500Mi"
    livenessProbe:
      exec:
        command:
          - bin/bash
          - -c
          - ./liveness.sh
      initialDelaySeconds: 60
      timeoutSeconds: 25
  volumes:
  - name: cwb-vol
    persistentVolumeClaim:
        claimName: cwb-pvc
"""


kubectlYaml= """
spec:
  containers:
  - name: alpine-pod
    image: alpine/git
    command:
    - sleep
    args:
    - infinity
"""

pipeline {
    options{
        timestamps()
        skipDefaultCheckout()
    }
	environment {
		NO_PROXY="localhost, 0.0.0.0/4201, 0.0.0.0/9876"
	}
    agent {
        kubernetes {
            label "${JOB_NAME}-${BUILD_NUMBER}-pipeline"
            yaml kubectlYaml
            showRawYaml false
            workspaceVolume dynamicPVC(accessModes: "ReadWriteMany", requestsSize: "2Gi", storageClassName: "standard")
        }
    }
    stages {
        stage("Set env"){
            steps{
                container('alpine-pod'){
                    script {
                        env.WORKSPACE_PVC = "pvc-workspace-${JENKINS_AGENT_NAME}"
                    }
                }
            }
        }
        stage('Setup Workspace') {
            agent {
                kubernetes {
                    label "${JOB_NAME}-${BUILD_NUMBER}-workspace"
                    yaml cwbPod
                    workspaceVolume persistentVolumeClaimWorkspaceVolume(claimName: "$WORKSPACE_PVC", readOnly: false)
					          showRawYaml false
                }
            }
            stages{
                stage('Yarn install'){
                    steps{
                        container('cwb-lint'){
                            sh ''' node -v && yarn --cache-folder /app/.yarn-cache '''
                        }
                    }
                }
            }
        }
        stage('Lint and Tests') {
            agent {
                kubernetes {
                    label "${JOB_NAME}-${BUILD_NUMBER}-lint"
                    yaml cwbPod
                    workspaceVolume persistentVolumeClaimWorkspaceVolume(claimName: "$WORKSPACE_PVC", readOnly: false)
					          showRawYaml false
                }
            }
            stages{
                stage('Linting'){
                    steps{
                        container('cwb-lint'){
							            sh " nx run-many --target=lint --all"
                        }
                    }
                }
            }
        }
        stage('Stages to run in Parallel') {
            steps {
                script {
                    parallel nx_specific_test_projects.collectEntries {
                        ["${it}" : generateStage(it, cwbUnitTestPod, "$WORKSPACE_PVC")]
                    }
                }
            }
        }
    }
    post {
        always {
            container('alpine-pod'){
				      junit (allowEmptyResults: true, testResults: "**/test-results-unit.xml")
            }
        }
		aborted {
            container('alpine-pod'){
                sh """
					echo "If you see this message in the log:\n (Exit Code: 137, Reason: Error)"
					echo "This might be due to a Out-of-Memory (OOM) error"

                """
            }
		}


    }
}

def generateStage(job, pod_file, pvc) {
    return {
        def project = job
        stage(job) {
            podTemplate(
                yamlFile:pod_file,
                showRawYaml: false,
                workspaceVolume: persistentVolumeClaimWorkspaceVolume(claimName: pvc, readOnly: false)
                )  {
                node(POD_LABEL) {
                    stage("${job}") {
                        container('cwb-test') {
                            sh """
                                echo "Running tests for project: ${job} in $HOSTNAME"
                                yarn run test --project ${job}
                                echo "Done with tests for ${job}!"
                            """
                        }
                    }
                }
            }
        }
    }
}


def get_base_branch () {
	return sh (script: 'devops/getBaseBranch.sh', returnStdout: true).trim()
}

def getAffectedApps(gitBase) {
	return sh (script: """
                yarn run affected:apps --base=${gitBase} --plain | grep -v yarn | grep -v Done | grep -v node_modules
                """, returnStdout: true).replace(' ',' ').trim()
}

def getAffectedLibs(gitBase) {
	return sh (script: """
                yarn run affected:libs --base=${gitBase} --plain | grep -v yarn | grep -v Done | grep -v node_modules
            """, returnStdout: true).replace(' ',' ').trim()
}

def getListToTest(affected_applications,affected_libraries) {
	def projects = readJSON file: 'angular.json'
	testAbleProjectList = []
	String[] myApplications = affected_applications.split(' ')
	String[] myLibraries = affected_libraries.split(' ')
	for (String application: myApplications) {
		projects['projects'].each { project, value ->
			if (project != application) {
				return
			}
			if (value['architect'].keySet().contains('test')) {
				testAbleProjectList.add(project);
			}
		}
	}
	for (String library: myLibraries) {
		projects['projects'].each { project, value ->
			if (project != library) {
				return
			}
			if (value['architect'].keySet().contains('test')) {
				testAbleProjectList.add(project);
			}
		}
	}
	return testAbleProjectList
}
